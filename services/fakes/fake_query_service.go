// Code generated by counterfeiter. DO NOT EDIT.
package fakes

import (
	"sync"

	cfclient "github.com/cloudfoundry-community/go-cfclient"
	"github.com/mike-carey/change-all-stacks/data"
	"github.com/mike-carey/change-all-stacks/services"
)

type FakeQueryService struct {
	FilterAppsByBuildpackNameStub        func([]cfclient.App, string) ([]cfclient.App, error)
	filterAppsByBuildpackNameMutex       sync.RWMutex
	filterAppsByBuildpackNameArgsForCall []struct {
		arg1 []cfclient.App
		arg2 string
	}
	filterAppsByBuildpackNameReturns struct {
		result1 []cfclient.App
		result2 error
	}
	filterAppsByBuildpackNameReturnsOnCall map[int]struct {
		result1 []cfclient.App
		result2 error
	}
	FilterAppsByStackNameStub        func([]cfclient.App, string) ([]cfclient.App, error)
	filterAppsByStackNameMutex       sync.RWMutex
	filterAppsByStackNameArgsForCall []struct {
		arg1 []cfclient.App
		arg2 string
	}
	filterAppsByStackNameReturns struct {
		result1 []cfclient.App
		result2 error
	}
	filterAppsByStackNameReturnsOnCall map[int]struct {
		result1 []cfclient.App
		result2 error
	}
	GetAllAppsWithinOrgsStub        func(...string) ([]cfclient.App, error)
	getAllAppsWithinOrgsMutex       sync.RWMutex
	getAllAppsWithinOrgsArgsForCall []struct {
		arg1 []string
	}
	getAllAppsWithinOrgsReturns struct {
		result1 []cfclient.App
		result2 error
	}
	getAllAppsWithinOrgsReturnsOnCall map[int]struct {
		result1 []cfclient.App
		result2 error
	}
	GetAppDataStub        func(string, []cfclient.App) (data.Data, error)
	getAppDataMutex       sync.RWMutex
	getAppDataArgsForCall []struct {
		arg1 string
		arg2 []cfclient.App
	}
	getAppDataReturns struct {
		result1 data.Data
		result2 error
	}
	getAppDataReturnsOnCall map[int]struct {
		result1 data.Data
		result2 error
	}
	GetBuildpackSetStub        func([]cfclient.App) ([]string, error)
	getBuildpackSetMutex       sync.RWMutex
	getBuildpackSetArgsForCall []struct {
		arg1 []cfclient.App
	}
	getBuildpackSetReturns struct {
		result1 []string
		result2 error
	}
	getBuildpackSetReturnsOnCall map[int]struct {
		result1 []string
		result2 error
	}
	GroupAppsByOrgAndSpaceStub        func([]cfclient.App) (map[string]map[string][]cfclient.App, error)
	groupAppsByOrgAndSpaceMutex       sync.RWMutex
	groupAppsByOrgAndSpaceArgsForCall []struct {
		arg1 []cfclient.App
	}
	groupAppsByOrgAndSpaceReturns struct {
		result1 map[string]map[string][]cfclient.App
		result2 error
	}
	groupAppsByOrgAndSpaceReturnsOnCall map[int]struct {
		result1 map[string]map[string][]cfclient.App
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeQueryService) FilterAppsByBuildpackName(arg1 []cfclient.App, arg2 string) ([]cfclient.App, error) {
	var arg1Copy []cfclient.App
	if arg1 != nil {
		arg1Copy = make([]cfclient.App, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.filterAppsByBuildpackNameMutex.Lock()
	ret, specificReturn := fake.filterAppsByBuildpackNameReturnsOnCall[len(fake.filterAppsByBuildpackNameArgsForCall)]
	fake.filterAppsByBuildpackNameArgsForCall = append(fake.filterAppsByBuildpackNameArgsForCall, struct {
		arg1 []cfclient.App
		arg2 string
	}{arg1Copy, arg2})
	fake.recordInvocation("FilterAppsByBuildpackName", []interface{}{arg1Copy, arg2})
	fake.filterAppsByBuildpackNameMutex.Unlock()
	if fake.FilterAppsByBuildpackNameStub != nil {
		return fake.FilterAppsByBuildpackNameStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.filterAppsByBuildpackNameReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeQueryService) FilterAppsByBuildpackNameCallCount() int {
	fake.filterAppsByBuildpackNameMutex.RLock()
	defer fake.filterAppsByBuildpackNameMutex.RUnlock()
	return len(fake.filterAppsByBuildpackNameArgsForCall)
}

func (fake *FakeQueryService) FilterAppsByBuildpackNameCalls(stub func([]cfclient.App, string) ([]cfclient.App, error)) {
	fake.filterAppsByBuildpackNameMutex.Lock()
	defer fake.filterAppsByBuildpackNameMutex.Unlock()
	fake.FilterAppsByBuildpackNameStub = stub
}

func (fake *FakeQueryService) FilterAppsByBuildpackNameArgsForCall(i int) ([]cfclient.App, string) {
	fake.filterAppsByBuildpackNameMutex.RLock()
	defer fake.filterAppsByBuildpackNameMutex.RUnlock()
	argsForCall := fake.filterAppsByBuildpackNameArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeQueryService) FilterAppsByBuildpackNameReturns(result1 []cfclient.App, result2 error) {
	fake.filterAppsByBuildpackNameMutex.Lock()
	defer fake.filterAppsByBuildpackNameMutex.Unlock()
	fake.FilterAppsByBuildpackNameStub = nil
	fake.filterAppsByBuildpackNameReturns = struct {
		result1 []cfclient.App
		result2 error
	}{result1, result2}
}

func (fake *FakeQueryService) FilterAppsByBuildpackNameReturnsOnCall(i int, result1 []cfclient.App, result2 error) {
	fake.filterAppsByBuildpackNameMutex.Lock()
	defer fake.filterAppsByBuildpackNameMutex.Unlock()
	fake.FilterAppsByBuildpackNameStub = nil
	if fake.filterAppsByBuildpackNameReturnsOnCall == nil {
		fake.filterAppsByBuildpackNameReturnsOnCall = make(map[int]struct {
			result1 []cfclient.App
			result2 error
		})
	}
	fake.filterAppsByBuildpackNameReturnsOnCall[i] = struct {
		result1 []cfclient.App
		result2 error
	}{result1, result2}
}

func (fake *FakeQueryService) FilterAppsByStackName(arg1 []cfclient.App, arg2 string) ([]cfclient.App, error) {
	var arg1Copy []cfclient.App
	if arg1 != nil {
		arg1Copy = make([]cfclient.App, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.filterAppsByStackNameMutex.Lock()
	ret, specificReturn := fake.filterAppsByStackNameReturnsOnCall[len(fake.filterAppsByStackNameArgsForCall)]
	fake.filterAppsByStackNameArgsForCall = append(fake.filterAppsByStackNameArgsForCall, struct {
		arg1 []cfclient.App
		arg2 string
	}{arg1Copy, arg2})
	fake.recordInvocation("FilterAppsByStackName", []interface{}{arg1Copy, arg2})
	fake.filterAppsByStackNameMutex.Unlock()
	if fake.FilterAppsByStackNameStub != nil {
		return fake.FilterAppsByStackNameStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.filterAppsByStackNameReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeQueryService) FilterAppsByStackNameCallCount() int {
	fake.filterAppsByStackNameMutex.RLock()
	defer fake.filterAppsByStackNameMutex.RUnlock()
	return len(fake.filterAppsByStackNameArgsForCall)
}

func (fake *FakeQueryService) FilterAppsByStackNameCalls(stub func([]cfclient.App, string) ([]cfclient.App, error)) {
	fake.filterAppsByStackNameMutex.Lock()
	defer fake.filterAppsByStackNameMutex.Unlock()
	fake.FilterAppsByStackNameStub = stub
}

func (fake *FakeQueryService) FilterAppsByStackNameArgsForCall(i int) ([]cfclient.App, string) {
	fake.filterAppsByStackNameMutex.RLock()
	defer fake.filterAppsByStackNameMutex.RUnlock()
	argsForCall := fake.filterAppsByStackNameArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeQueryService) FilterAppsByStackNameReturns(result1 []cfclient.App, result2 error) {
	fake.filterAppsByStackNameMutex.Lock()
	defer fake.filterAppsByStackNameMutex.Unlock()
	fake.FilterAppsByStackNameStub = nil
	fake.filterAppsByStackNameReturns = struct {
		result1 []cfclient.App
		result2 error
	}{result1, result2}
}

func (fake *FakeQueryService) FilterAppsByStackNameReturnsOnCall(i int, result1 []cfclient.App, result2 error) {
	fake.filterAppsByStackNameMutex.Lock()
	defer fake.filterAppsByStackNameMutex.Unlock()
	fake.FilterAppsByStackNameStub = nil
	if fake.filterAppsByStackNameReturnsOnCall == nil {
		fake.filterAppsByStackNameReturnsOnCall = make(map[int]struct {
			result1 []cfclient.App
			result2 error
		})
	}
	fake.filterAppsByStackNameReturnsOnCall[i] = struct {
		result1 []cfclient.App
		result2 error
	}{result1, result2}
}

func (fake *FakeQueryService) GetAllAppsWithinOrgs(arg1 ...string) ([]cfclient.App, error) {
	fake.getAllAppsWithinOrgsMutex.Lock()
	ret, specificReturn := fake.getAllAppsWithinOrgsReturnsOnCall[len(fake.getAllAppsWithinOrgsArgsForCall)]
	fake.getAllAppsWithinOrgsArgsForCall = append(fake.getAllAppsWithinOrgsArgsForCall, struct {
		arg1 []string
	}{arg1})
	fake.recordInvocation("GetAllAppsWithinOrgs", []interface{}{arg1})
	fake.getAllAppsWithinOrgsMutex.Unlock()
	if fake.GetAllAppsWithinOrgsStub != nil {
		return fake.GetAllAppsWithinOrgsStub(arg1...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getAllAppsWithinOrgsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeQueryService) GetAllAppsWithinOrgsCallCount() int {
	fake.getAllAppsWithinOrgsMutex.RLock()
	defer fake.getAllAppsWithinOrgsMutex.RUnlock()
	return len(fake.getAllAppsWithinOrgsArgsForCall)
}

func (fake *FakeQueryService) GetAllAppsWithinOrgsCalls(stub func(...string) ([]cfclient.App, error)) {
	fake.getAllAppsWithinOrgsMutex.Lock()
	defer fake.getAllAppsWithinOrgsMutex.Unlock()
	fake.GetAllAppsWithinOrgsStub = stub
}

func (fake *FakeQueryService) GetAllAppsWithinOrgsArgsForCall(i int) []string {
	fake.getAllAppsWithinOrgsMutex.RLock()
	defer fake.getAllAppsWithinOrgsMutex.RUnlock()
	argsForCall := fake.getAllAppsWithinOrgsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeQueryService) GetAllAppsWithinOrgsReturns(result1 []cfclient.App, result2 error) {
	fake.getAllAppsWithinOrgsMutex.Lock()
	defer fake.getAllAppsWithinOrgsMutex.Unlock()
	fake.GetAllAppsWithinOrgsStub = nil
	fake.getAllAppsWithinOrgsReturns = struct {
		result1 []cfclient.App
		result2 error
	}{result1, result2}
}

func (fake *FakeQueryService) GetAllAppsWithinOrgsReturnsOnCall(i int, result1 []cfclient.App, result2 error) {
	fake.getAllAppsWithinOrgsMutex.Lock()
	defer fake.getAllAppsWithinOrgsMutex.Unlock()
	fake.GetAllAppsWithinOrgsStub = nil
	if fake.getAllAppsWithinOrgsReturnsOnCall == nil {
		fake.getAllAppsWithinOrgsReturnsOnCall = make(map[int]struct {
			result1 []cfclient.App
			result2 error
		})
	}
	fake.getAllAppsWithinOrgsReturnsOnCall[i] = struct {
		result1 []cfclient.App
		result2 error
	}{result1, result2}
}

func (fake *FakeQueryService) GetAppData(arg1 string, arg2 []cfclient.App) (data.Data, error) {
	var arg2Copy []cfclient.App
	if arg2 != nil {
		arg2Copy = make([]cfclient.App, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.getAppDataMutex.Lock()
	ret, specificReturn := fake.getAppDataReturnsOnCall[len(fake.getAppDataArgsForCall)]
	fake.getAppDataArgsForCall = append(fake.getAppDataArgsForCall, struct {
		arg1 string
		arg2 []cfclient.App
	}{arg1, arg2Copy})
	fake.recordInvocation("GetAppData", []interface{}{arg1, arg2Copy})
	fake.getAppDataMutex.Unlock()
	if fake.GetAppDataStub != nil {
		return fake.GetAppDataStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getAppDataReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeQueryService) GetAppDataCallCount() int {
	fake.getAppDataMutex.RLock()
	defer fake.getAppDataMutex.RUnlock()
	return len(fake.getAppDataArgsForCall)
}

func (fake *FakeQueryService) GetAppDataCalls(stub func(string, []cfclient.App) (data.Data, error)) {
	fake.getAppDataMutex.Lock()
	defer fake.getAppDataMutex.Unlock()
	fake.GetAppDataStub = stub
}

func (fake *FakeQueryService) GetAppDataArgsForCall(i int) (string, []cfclient.App) {
	fake.getAppDataMutex.RLock()
	defer fake.getAppDataMutex.RUnlock()
	argsForCall := fake.getAppDataArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeQueryService) GetAppDataReturns(result1 data.Data, result2 error) {
	fake.getAppDataMutex.Lock()
	defer fake.getAppDataMutex.Unlock()
	fake.GetAppDataStub = nil
	fake.getAppDataReturns = struct {
		result1 data.Data
		result2 error
	}{result1, result2}
}

func (fake *FakeQueryService) GetAppDataReturnsOnCall(i int, result1 data.Data, result2 error) {
	fake.getAppDataMutex.Lock()
	defer fake.getAppDataMutex.Unlock()
	fake.GetAppDataStub = nil
	if fake.getAppDataReturnsOnCall == nil {
		fake.getAppDataReturnsOnCall = make(map[int]struct {
			result1 data.Data
			result2 error
		})
	}
	fake.getAppDataReturnsOnCall[i] = struct {
		result1 data.Data
		result2 error
	}{result1, result2}
}

func (fake *FakeQueryService) GetBuildpackSet(arg1 []cfclient.App) ([]string, error) {
	var arg1Copy []cfclient.App
	if arg1 != nil {
		arg1Copy = make([]cfclient.App, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.getBuildpackSetMutex.Lock()
	ret, specificReturn := fake.getBuildpackSetReturnsOnCall[len(fake.getBuildpackSetArgsForCall)]
	fake.getBuildpackSetArgsForCall = append(fake.getBuildpackSetArgsForCall, struct {
		arg1 []cfclient.App
	}{arg1Copy})
	fake.recordInvocation("GetBuildpackSet", []interface{}{arg1Copy})
	fake.getBuildpackSetMutex.Unlock()
	if fake.GetBuildpackSetStub != nil {
		return fake.GetBuildpackSetStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getBuildpackSetReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeQueryService) GetBuildpackSetCallCount() int {
	fake.getBuildpackSetMutex.RLock()
	defer fake.getBuildpackSetMutex.RUnlock()
	return len(fake.getBuildpackSetArgsForCall)
}

func (fake *FakeQueryService) GetBuildpackSetCalls(stub func([]cfclient.App) ([]string, error)) {
	fake.getBuildpackSetMutex.Lock()
	defer fake.getBuildpackSetMutex.Unlock()
	fake.GetBuildpackSetStub = stub
}

func (fake *FakeQueryService) GetBuildpackSetArgsForCall(i int) []cfclient.App {
	fake.getBuildpackSetMutex.RLock()
	defer fake.getBuildpackSetMutex.RUnlock()
	argsForCall := fake.getBuildpackSetArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeQueryService) GetBuildpackSetReturns(result1 []string, result2 error) {
	fake.getBuildpackSetMutex.Lock()
	defer fake.getBuildpackSetMutex.Unlock()
	fake.GetBuildpackSetStub = nil
	fake.getBuildpackSetReturns = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeQueryService) GetBuildpackSetReturnsOnCall(i int, result1 []string, result2 error) {
	fake.getBuildpackSetMutex.Lock()
	defer fake.getBuildpackSetMutex.Unlock()
	fake.GetBuildpackSetStub = nil
	if fake.getBuildpackSetReturnsOnCall == nil {
		fake.getBuildpackSetReturnsOnCall = make(map[int]struct {
			result1 []string
			result2 error
		})
	}
	fake.getBuildpackSetReturnsOnCall[i] = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeQueryService) GroupAppsByOrgAndSpace(arg1 []cfclient.App) (map[string]map[string][]cfclient.App, error) {
	var arg1Copy []cfclient.App
	if arg1 != nil {
		arg1Copy = make([]cfclient.App, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.groupAppsByOrgAndSpaceMutex.Lock()
	ret, specificReturn := fake.groupAppsByOrgAndSpaceReturnsOnCall[len(fake.groupAppsByOrgAndSpaceArgsForCall)]
	fake.groupAppsByOrgAndSpaceArgsForCall = append(fake.groupAppsByOrgAndSpaceArgsForCall, struct {
		arg1 []cfclient.App
	}{arg1Copy})
	fake.recordInvocation("GroupAppsByOrgAndSpace", []interface{}{arg1Copy})
	fake.groupAppsByOrgAndSpaceMutex.Unlock()
	if fake.GroupAppsByOrgAndSpaceStub != nil {
		return fake.GroupAppsByOrgAndSpaceStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.groupAppsByOrgAndSpaceReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeQueryService) GroupAppsByOrgAndSpaceCallCount() int {
	fake.groupAppsByOrgAndSpaceMutex.RLock()
	defer fake.groupAppsByOrgAndSpaceMutex.RUnlock()
	return len(fake.groupAppsByOrgAndSpaceArgsForCall)
}

func (fake *FakeQueryService) GroupAppsByOrgAndSpaceCalls(stub func([]cfclient.App) (map[string]map[string][]cfclient.App, error)) {
	fake.groupAppsByOrgAndSpaceMutex.Lock()
	defer fake.groupAppsByOrgAndSpaceMutex.Unlock()
	fake.GroupAppsByOrgAndSpaceStub = stub
}

func (fake *FakeQueryService) GroupAppsByOrgAndSpaceArgsForCall(i int) []cfclient.App {
	fake.groupAppsByOrgAndSpaceMutex.RLock()
	defer fake.groupAppsByOrgAndSpaceMutex.RUnlock()
	argsForCall := fake.groupAppsByOrgAndSpaceArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeQueryService) GroupAppsByOrgAndSpaceReturns(result1 map[string]map[string][]cfclient.App, result2 error) {
	fake.groupAppsByOrgAndSpaceMutex.Lock()
	defer fake.groupAppsByOrgAndSpaceMutex.Unlock()
	fake.GroupAppsByOrgAndSpaceStub = nil
	fake.groupAppsByOrgAndSpaceReturns = struct {
		result1 map[string]map[string][]cfclient.App
		result2 error
	}{result1, result2}
}

func (fake *FakeQueryService) GroupAppsByOrgAndSpaceReturnsOnCall(i int, result1 map[string]map[string][]cfclient.App, result2 error) {
	fake.groupAppsByOrgAndSpaceMutex.Lock()
	defer fake.groupAppsByOrgAndSpaceMutex.Unlock()
	fake.GroupAppsByOrgAndSpaceStub = nil
	if fake.groupAppsByOrgAndSpaceReturnsOnCall == nil {
		fake.groupAppsByOrgAndSpaceReturnsOnCall = make(map[int]struct {
			result1 map[string]map[string][]cfclient.App
			result2 error
		})
	}
	fake.groupAppsByOrgAndSpaceReturnsOnCall[i] = struct {
		result1 map[string]map[string][]cfclient.App
		result2 error
	}{result1, result2}
}

func (fake *FakeQueryService) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.filterAppsByBuildpackNameMutex.RLock()
	defer fake.filterAppsByBuildpackNameMutex.RUnlock()
	fake.filterAppsByStackNameMutex.RLock()
	defer fake.filterAppsByStackNameMutex.RUnlock()
	fake.getAllAppsWithinOrgsMutex.RLock()
	defer fake.getAllAppsWithinOrgsMutex.RUnlock()
	fake.getAppDataMutex.RLock()
	defer fake.getAppDataMutex.RUnlock()
	fake.getBuildpackSetMutex.RLock()
	defer fake.getBuildpackSetMutex.RUnlock()
	fake.groupAppsByOrgAndSpaceMutex.RLock()
	defer fake.groupAppsByOrgAndSpaceMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeQueryService) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ services.QueryService = new(FakeQueryService)
