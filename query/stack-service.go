// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package query

import (
	"fmt"
	"sync"

	cfclient "github.com/cloudfoundry-community/go-cfclient"
	"github.com/mike-carey/change-all-stacks/logger"
)

type StackService struct {
	client      CFClient
	cacheList   []cfclient.Stack
	cacheMap    map[string]cfclient.Stack
	mutex       *sync.Mutex
	fullyLoaded bool
}

func NewStackService(client CFClient) *StackService {
	return &StackService{
		client:      client,
		cacheList:   make([]cfclient.Stack, 0),
		cacheMap:    make(map[string]cfclient.Stack, 0),
		mutex:       &sync.Mutex{},
		fullyLoaded: false,
	}
}

func (s *StackService) lock() {
	logger.Debugf("Locking %T", s)
	s.mutex.Lock()
	logger.Debugf("Locked %T", s)
}

func (s *StackService) unlock() {
	logger.Debugf("Unlocking %T", s)
	s.mutex.Unlock()
	logger.Debugf("Unlocked %T", s)
}

func (s *StackService) GetAllStacks() ([]cfclient.Stack, error) {
	s.lock()

	if !s.fullyLoaded {
		logger.Debugf("%T is not already fully loaded", s)
		items, err := s.client.ListStacks()
		if err != nil {
			return nil, err
		}

		logger.Debugf("Writing cache list for %T", s)
		s.cacheList = items

		go func(s *StackService, items []cfclient.Stack) {
			defer s.unlock()

			logger.Debugf("Writing cache map for %T", s)
			for _, item := range items {
				s.cacheMap[item.Guid] = item
			}
		}(s, items)
	} else {
		defer s.unlock()
	}

	return s.cacheList, nil
}

func (s *StackService) GetStackByGuid(guid string) (cfclient.Stack, error) {
	s.lock()
	//defer s.unlock()

	if item, ok := s.cacheMap[guid]; ok {
		logger.Debugf("Found a cached %T with a guid of %s", item, guid)
		return item, nil
	}

	if s.fullyLoaded {
		logger.Debugf("%T is already fully loaded but did not find %s in cacheMap", s, guid)
		item := cfclient.Stack{}
		return item, NewNotFoundError(item, "guid", guid)
	}

	logger.Debugf("Did not find cached %T and %T is not fully loaded, querying by guid: %s", cfclient.Stack{}, s, guid)
	s.unlock()
	i, err := s.getStackByGuid(guid)
	if err != nil {
		return cfclient.Stack{}, nil
	}

	logger.Debugf("Saving off a single %T to the cacheMap with guid: %s", i, i.Guid)
	s.cacheMap[i.Guid] = i
	return i, nil
}

func (s *StackService) GetStackByName(name string) (cfclient.Stack, error) {
	items, err := s.GetAllStacks()
	if err != nil {
		return cfclient.Stack{}, err
	}

	s.lock()
	defer s.unlock()

	for _, item := range items {
		if item.Name == name {
			return item, nil
		}
	}

	item := cfclient.Stack{}
	return item, NewNotFoundError(item, "name", name)
}

// Proxy all functions onto the inquisitor struct
func (i *inquisitor) GetAllStacks() ([]cfclient.Stack, error) {
	return i.getStackService().GetAllStacks()
}

func (i *inquisitor) GetStackByGuid(guid string) (cfclient.Stack, error) {
	return i.getStackService().GetStackByGuid(guid)
}

func (i *inquisitor) GetStackByName(name string) (cfclient.Stack, error) {
	return i.getStackService().GetStackByName(name)
}

// Worksaround until merge: https://github.com/cloudfoundry-community/go-cfclient/pull/234
func (s *StackService) getStackByGuid(guid string) (cfclient.Stack, error) {
	// Grab all stacks and find the one that has the desired guid
	stacks, err := s.GetAllStacks()
	if err != nil {
		return cfclient.Stack{}, nil
	}

	for _, stack := range stacks {
		if stack.Guid == guid {
			return stack, nil
		}
	}

	return cfclient.Stack{}, fmt.Errorf("Could not find stack with guid: '%s'", guid)
}
