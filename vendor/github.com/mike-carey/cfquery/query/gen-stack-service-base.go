// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package query

import (
	"fmt"
	"reflect"
	"strings"
	"sync"

	"github.com/cloudfoundry-community/go-cfclient"
	"github.com/mike-carey/cfquery/cf"
	"github.com/mike-carey/cfquery/logger"
	"github.com/mike-carey/cfquery/util"
)

type StackService struct {
	Client      cf.CFClient
	storage     StackMap
	filled      bool
	mutex       *sync.Mutex
	serviceName string
	key         string
}

func NewStackService(client cf.CFClient) *StackService {
	return &StackService{
		Client:  client,
		storage: make(map[string]cfclient.Stack, 0),
		filled:  false,
		mutex:   &sync.Mutex{},
	}
}

func (s *StackService) ServiceName() string {
	if s.serviceName == "" {
		name := fmt.Sprintf("%T", s)

		_name := strings.Split(name, ".")
		name = _name[len(_name)-1]

		s.serviceName = fmt.Sprintf("%s", name)
	}

	return s.serviceName
}

func (s *StackService) Key() string {
	if s.key == "" {
		key := s.ServiceName()
		s.key = key[:len(key)-len("Service")]
		logger.Info(s.key)
	}

	return s.key
}

func (s *StackService) lock() {
	s.mutex.Lock()
	logger.Infof("Locked %v", reflect.TypeOf(s))
}

func (s *StackService) unlock() {
	s.mutex.Unlock()
	logger.Infof("Unlocked %v", reflect.TypeOf(s))
}

func (s *StackService) GetStackMap() (StackMap, error) {
	_, err := s.GetAllStacks()
	if err != nil {
		return nil, err
	}

	return s.storage, nil
}

func (i *inquisitor) GetStackMap() (StackMap, error) {
	return i.getStackService().GetStackMap()
}

func (s *StackService) GetStackByGuid(guid string) (*cfclient.Stack, error) {
	s.lock()

	defer s.unlock()

	if s.filled {
		if val, ok := s.storage[guid]; ok {
			return &val, nil
		}
	}

	logger.Infof("Did not find %s in storage", guid)
	item, err := s.getStackByGuid(guid)
	if err != nil {
		return nil, err
	}

	// Save off in storage
	s.storage[guid] = item

	return &item, nil
}

func (i *inquisitor) GetStackByGuid(guid string) (*cfclient.Stack, error) {
	return i.getStackService().GetStackByGuid(guid)
}

func (s *StackService) GetManyStacksByGuid(guids ...string) (StackMap, error) {
	pool := make(StackMap, len(guids))

	type Result struct {
		Guid   string
		Object *cfclient.Stack
		Error  error
	}

	resCh := make(chan Result, len(guids))

	for _, guid := range guids {
		go func(guid string) {
			obj, err := s.GetStackByGuid(guid)
			res := Result{
				Guid:   guid,
				Error:  err,
				Object: obj,
			}

			resCh <- res
		}(guid)
	}

	errs := make([]error, 0)

	for _, _ = range guids {
		select {
		case res := <-resCh:
			if res.Error != nil {
				errs = append(errs, res.Error)
			}

			pool[res.Guid] = *res.Object
		}
	}

	if len(errs) > 0 {
		return nil, util.StackErrors(errs)
	}

	return pool, nil
}

func (i *inquisitor) GetManyStacksByGuid(guids ...string) (StackMap, error) {
	return i.getStackService().GetManyStacksByGuid(guids...)
}

func (s *StackService) GetAllStacks() (Stacks, error) {
	s.lock()

	if s.filled {
		logger.Infof("Reusing storage")
		siSlice := make(Stacks, 0, len(s.storage))
		for _, si := range s.storage {
			siSlice = append(siSlice, si)
		}

		s.unlock()

		return siSlice, nil
	}

	logger.Infof("Calling out to CFClient")
	sis, err := s.Client.ListStacks()
	if err != nil {
		return nil, err
	}

	go func(s *StackService, sis Stacks) {
		logger.Infof("Storing contents to storage")
		for _, si := range sis {
			s.storage[si.Guid] = si
		}

		logger.Infof("Done storing contents to storage")
		s.filled = true

		s.unlock()
	}(s, sis)

	logger.Infof("Returning list while populating happens")
	return sis, nil
}

func (i *inquisitor) GetAllStacks() (Stacks, error) {
	return i.getStackService().GetAllStacks()
}

func (i *inquisitor) newStackService() *StackService {
	return NewStackService(i.CFClient)
}

func (i *inquisitor) getStackService() *StackService {
	class := &StackService{}
	key := class.Key()

	if service, ok := i.services[key]; ok {
		return service.(*StackService)
	}

	service := i.newStackService()

	i.lock()
	i.services[key] = service
	i.unlock()

	return service
}

func (s *StackService) getStackByGuid(guid string) (cfclient.Stack, error) {
	// Grab all stacks and find the one that has the desired guid
	stacks, err := s.GetAllStacks()
	if err != nil {
		return cfclient.Stack{}, nil
	}

	for _, stack := range stacks {
		if stack.Guid == guid {
			return stack, nil
		}
	}

	return cfclient.Stack{}, fmt.Errorf("Could not find stack with guid: '%s'", guid)
}
